package  {	import flash.display.MovieClip;	import flash.events.Event;		public class flyingNinja extends MovieClip {		public var evilPaddle:MovieClip;		var ball:Ball; 		var mainRef;		public function flyingNinja(ePaddle:MovieClip,theBall:Ball,mainR:FlashForceMain) {			this.evilPaddle = ePaddle;			this.ball = theBall;			this.mainRef = mainR;						//Re-engineer this so that the creator of flyingNinjas makes one set			//in an array which is retained and re-used to avoid GC.			//Best case scenario would implement this as a mortal object pool (MOP)			//where MOP is defined as an object pool that has a limited life-span			//If it is not called upon for X ms, it nulls (at least) its child references and they become			//eligible for GC.  A MOP automatically checks for an empty pool and fills it when it is next called if			//its timeout occurs.			//When a star is needed, the creator calls activate on each flyingNinja object			//ball.addChild(this);			//this.addEventListener(Event.ENTER_FRAME, fly);		}				public function activateStar(){			ball.addChild(this);			this.addEventListener(Event.ENTER_FRAME, fly);					}				public function fly(event:Event){			if (this.parent == null){				this.removeEventListener(Event.ENTER_FRAME, fly);			}			if (this.parent != null){			this.y -= 10;			//trace("myParent: " + this.parent);			//trace("ninja y: " + this.y);				if (this.hitTestObject(evilPaddle)){					mainRef.numStars--;					this.removeEventListener(Event.ENTER_FRAME, fly);					ball.removeChild(this);				}				else if (this.y <= 40){					//var callParts:CallParts = new CallParts((this.x + (this.width/2)),50);					//ball.addChild(callParts);					ball.ex.showExplosion(this.x,this.y,2);					ball.playerScore += 1;					ball.score.text = "PLAYER SCORE: " + ball.playerScore;					mainRef.numStars--;					this.removeEventListener(Event.ENTER_FRAME, fly);					ball.removeChild(this);					if (ball.playerScore >= 10){						ball.playerWin();					}									}			}		}			}	}